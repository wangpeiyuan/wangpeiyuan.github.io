<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>源来似你</title>
  
  <subtitle>一个向往自由的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangpeiyuan.cn/"/>
  <updated>2019-11-26T14:37:45.550Z</updated>
  <id>http://wangpeiyuan.cn/</id>
  
  <author>
    <name>王培源</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>带着问题浅析源码 - Handler 源码浅析</title>
    <link href="http://wangpeiyuan.cn/2019/11/26/Android-handler-source-code-analysis/"/>
    <id>http://wangpeiyuan.cn/2019/11/26/Android-handler-source-code-analysis/</id>
    <published>2019-11-26T14:22:32.000Z</published>
    <updated>2019-11-26T14:37:45.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Handler 在我们日常开发中随处可见，一般用来解决子线程无法访问主线程（UI 线程）中的 UI 问题的。</p><p>下文会通过 Handler 的基本用法，并深入源码浅析 Handler 的运行机制。</p><a id="more"></a><h2 id="二、Handler-基本用法"><a href="#二、Handler-基本用法" class="headerlink" title="二、Handler 基本用法"></a>二、Handler 基本用法</h2><p>首先，我们先来简单过一下 Handler 的几种用法。</p><p>第一种：主线程实例化一个 Handler 并重写 <code>handleMessage</code> 方法，然后在需要的时候调用 <code>send</code> 或 <code>post</code> 等系列方法就行。此时 <code>handleMessage</code> 和  <code>Runnable</code>  运行在主线程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程</span></span><br><span class="line"><span class="keyword">val</span> handler: Handler = <span class="keyword">object</span> : Handler() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子线程发送消息</span></span><br><span class="line">Thread &#123;</span><br><span class="line">    <span class="comment">//第一种用法：子线程发送 msg</span></span><br><span class="line">    <span class="keyword">val</span> msg: Message = handler.obtainMessage()</span><br><span class="line">    handler.sendMessage(msg)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种用法：post</span></span><br><span class="line">    handler.post &#123;</span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><p>第二种：在子线程实例化 Handler，需要注意是在实例化之前要先创建 Looper，否则会抛出 <code>Can&#39;t create handler inside thread...</code> 异常。创建 Looper 有两种方式，一是调用 <code>Looper.prepare()</code> ，此时 Handler 运行在子线程中；二是调用 <code>Looper.getMainLooper()</code> 得到 Looper 并作为实例化 Handler 时构造函数的参数，此时 Handler 运行在主线程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//handler 运行在子线程</span></span><br><span class="line"><span class="keyword">var</span> handler: Handler</span><br><span class="line">Thread &#123;</span><br><span class="line">    Looper.prepare()</span><br><span class="line">    handler = <span class="keyword">object</span> : Handler() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.loop()</span><br><span class="line">&#125;.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//handler 运行在主线程</span></span><br><span class="line">Thread &#123;</span><br><span class="line">    <span class="keyword">val</span> looper = Looper.getMainLooper()</span><br><span class="line">    handler = <span class="keyword">object</span> : Handler(looper) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><p>通过这两种简单的使用，如果我们进一步想的话，会产生几个疑问，比如：</p><ol><li><strong>为啥在子线程需要调用 <code>Looper.prepare()</code> 等方式而主线程却不需要？</strong></li><li><strong><code>send</code> 和 <code>post</code> 之后做了什么处理，<code>handleMessage</code> 什么时候接收到消息？</strong></li><li><strong>常常听说的 MessageQueue 到哪去了？</strong></li><li><strong>Handler 是如何保证所在的运行线程的，线程又是如何切换的？</strong></li></ol><p>接下来，让我们一起进入源码的世界来一一解开这些疑惑。</p><h2 id="三、Handler-源码浅析"><a href="#三、Handler-源码浅析" class="headerlink" title="三、Handler 源码浅析"></a>三、Handler 源码浅析</h2><blockquote><p>注：基于 Android SDK 28 进行解析。涉及到的代码会做简化处理，只保留关键部分的代码。</p></blockquote><p>先说一下本篇文章阅读源码的顺序，先看看 Handler 实例化过程中做哪些初始化操作，然后 <code>send</code> 和 <code>post</code> 之后又是将 Message 发送给谁，之后的流程又是怎样，同时在阅读过程中来解答上一节的疑问。</p><h3 id="3-1-Handler-实例化"><a href="#3-1-Handler-实例化" class="headerlink" title="3.1 Handler 实例化"></a>3.1 Handler 实例化</h3><p>在跟进 Handler 的构造方法之后，我们会发现 Handler 在实例化时会为三个属性赋值：</p><ol><li>第一个是 <code>mLooper</code> 通过 <code>Looper.myLooper()</code> 取值，同时检查 Looper 是否为空，为空时抛出异常；</li><li>第二个是 <code>mQueue</code> 这个就是我们心心念念的 MessageQueue，可以发现它是由 Looper 持有的，具体的解析看下一节【<strong>Message 管理与分发</strong>】；</li><li>还有个是 <code>mCallback</code> ，这个相关解析可以看下一节【<strong>Message 管理与分发</strong>】。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略了部分代码，后续看到 //... 这个就代表简略了代码</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法中其实没有太多的东西，接下来我们看看 <code>Looper.myLooper()</code> 是如何获取到 Looper 实例的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，通过 <code>ThreadLocal.get()</code> 获取，既然有 <code>get</code> 那么肯定有对应的 <code>set</code> 方法，那在什么地方 set 呢？</p><p>这时候我们就要回想一下，在子线程中使用 Handler 是有三个步骤的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Looper.prepare()</span><br><span class="line">2. var handler: Handler = Handler()</span><br><span class="line">3. Looper.loop()</span><br></pre></td></tr></table></figure><p>我们此时是在第 2 中，那 <code>ThreadLocal.set()</code> 的设置是不是在 <code>Looper.prepare()</code> 中呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，是的。</p><p>这时我们就可以得到一个小小结论：Looper 提供一个 <code>Looper.prepare()</code> 方法来创建 Looper 对象，并将该对象放到 ThreadLocal 中，等 Handler 实例化的时候取出该 Looper 实例。</p><p>那 ThreadLocal 又是什么，怎么保证 Handler 实例化获取的 Looper 正好是我们创建的那个呢？</p><p><strong>ThreadLocal：线程本地存储区（Thread Local Storage）,每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的本地存储区。</strong></p><p>有个 ThreadLocal 概念之后，接下来看看 <code>ThreadLocal.set()</code> 做了哪些处理。</p><blockquote><p>注：这边的泛型 T 指的是 Looper 类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以发现 ThreadLocal 内部通过一个 ThreadLocalMap 键值对来保存 Looper 实例，同时这个 Map 保存在当前线程中。</p><p>再来看看 <code>ThreadLocal.get()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，获取 Looper 实例时也是先从当前线程中先获取 ThreadLocalMap，再根据当前 ThreadLocal 对象作为 key 来获取对应的 Looper 实例。</p><p>通过 ThreadLocal 的 <code>set</code> 和 <code>get</code> 方法，我们可以比较清晰的发现在 Handler 当中：ThreadLocal 是用来实现 Thread 和 Looper 的关联的。</p><p>经过上面的分析，我们现在就可以来解答【<strong>疑问 1</strong>】（为啥在子线程需要调用 <code>Looper.prepare()</code> 等方式而主线程却不需要？）：<strong>在 Handler 实例化中会调用 <code>Looper.myLooper()</code> 获取 Looper 实例对象，然而此对象最终是保存在当前线程的 ThreadLocalMap 中的，如果在 Handler 实例化之前不先调用 <code>Looper.prepare()</code> 来创建对应的 Looper 实例，那么 <code>Looper.myLooper()</code> 获取到的是一个 <code>null</code> 值，这就会导致在检测 <code>mLooper</code> 是否为空时抛出异常。</strong></p><p>因此我们可以得出这么一个结论：<strong>在任意一个线程中要实例化 Handler 必须要先调用 <code>Looper.prepare()</code>  来优先创建 Looper 保证当前线程中有一个 Looper 实例，否则就会抛异常。</strong></p><p>这时，细心的你会说，这个结论不对啊，为什么主线程使用 Handler 就不用调用 <code>Looper.prepare()</code>  呢？</p><p>确实我们在主线程使用 Handler 的时候并没有做额外的创建 Looper 工作，那主线程难道就是一个特殊的线程，就可以不用创建一个 Looper 实例吗？其实并不是的，主线程也不例外，为什么呢，那是因为 ActivityThread。</p><p>通常我们认为 ActivityThread 就是主线程也可以说是 UI 线程，但其实它并不是一个线程，而是主线程操作的一个管理者，认为它是主线程也是可以的。ActivityThread 中的有个 <code>main()</code> 方法它是 APP 的入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <strong>ActivityThread 的 <code>main()</code> 方法中调用了 <code>Looper.prepareMainLooper()</code> 创建了属于主线程的 Looper，因此我们就可以在主线程中直接使用 Handler。</strong></p><h3 id="3-2-Message-管理与分发"><a href="#3-2-Message-管理与分发" class="headerlink" title="3.2 Message 管理与分发"></a>3.2 Message 管理与分发</h3><p>在【<strong>Handler 基本用法</strong>】中可以发现消息是通过 <code>sendMessage()</code> 和 <code>post()</code> 来发送的，但其实 Handler 提供了  <code>send</code> 和 <code>post</code> 为开头的一系列方法。</p><p>跟进代码之后，我们会发现其实这系列的方法最终都会走到 <code>Handler().enqueueMessage()</code> 方法中。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Handler.java</span><br><span class="line">sendMessage(Message msg)</span><br><span class="line"> -&gt; sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">  -&gt; sendMessageAtTime(Message msg, long uptimeMillis)</span><br><span class="line">   -&gt; enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</span><br></pre></td></tr></table></figure><p><strong><code>post</code> 虽然参数是 Runnable 但最终也是一个 Message。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来详细看下 <code>Handler().enqueueMessage()</code> 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 MessageQueue 在这里又出现，在前面【<strong>Handler 实例化</strong>】中出现了两次，一次是在初始化 Handler 的时候通过 <code>mLooper.mQueue</code> 进行赋值，另一次是在 Looper 初始化中创建了 MessageQueue 的对象。</p><p><strong>MessageQueue 顾名思义是一个消息队列，负责消息的入队出队。内部是一个单链表。</strong></p><p>这个方法比较简单，主要是调用 <code>queue.enqueueMessage</code> 对消息进行了入队处理，需要注意的是 <code>msg.target = this</code> 这个后面解析会使用到，先记着。</p><p>我们接着往下跟 <code>MessageQueue.enqueueMessage()</code> ，看看消息是如何添加到队列中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然看起来有点长，但逻辑还是很清晰的，这里就不一一解释。可以发现<strong>MessageQueue 是一个按照 Message 触发时间（<code>when</code> 的大小）的先后顺序排序的，队头是最早要触发的消息。因此当一个消息要进入队列的时候，会从头开始开始遍历，直到找到该消息合适的插入位置，来保证整个队列消息的时间顺序</strong>。</p><p>到这里我们已经清楚的知道，Handler <code>send</code> 或 <code>post</code> 消息之后是由 MessageQueue 按照时间顺序来存储 Message 的，那 Message 又是何时由谁来触发的呢？</p><p>说到这里，我们就要先回顾一下，线程使用 Handler 的三个步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Looper.prepare()</span><br><span class="line">2. var handler: Handler = Handler()</span><br><span class="line">3. Looper.loop()</span><br></pre></td></tr></table></figure><p>在此之前我们已经解析了 1、2 两个步骤，那 <code>Looper.loop()</code> 这个方法是不是用来分发 Message 的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<code>Looper.loop()</code> 确实用来分发 Message 的。进入 <code>loop</code> 之后会有个 for 的无限循环，在这个循环当中，<strong>首先从 MessageQueue 中读取下一条 Message，然后将 Message 分发给对应的 <code>target</code> 处理，最后将该 Message 回收到消息池方便复用，不断的重复以上三个步骤，直到没有消息时退出循环</strong>。</p><p>接着我们看看 <code>queue.next()</code> 到底如何读取 Message 的，同时这边还有个注释 <code>might block （可能阻塞）</code>，一起看看到底怎么回事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//阻塞操作，等待 nextPollTimeoutMillis 时长或者消息队列被唤醒时会返回，是一个 native 方法</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// ... 关于 IdleHandler 可以在 [四、Handler 扩展] 中查看</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有个 <code>nativePollOnce()</code> 的 native 的阻塞操作，<code>nextPollTimeoutMillis</code> 是指阻塞的时长，当 <code>nextPollTimeoutMillis = -1</code> 时代表此时消息队列中没有消息，会一直等待下去。<strong>可以发现延时消息就是在这里实现的。</strong></p><p>关于阻塞还有个问题，通过代码可以知道 <code>Looper.loop()</code> 内部是一个死循环，那么它为什么不会卡死呢？这个问题的答案可以查看 【*<em>六、参考与推荐 1 *</em>】的文章。</p><p>看完  <code>queue.next()</code> 消息的读取，接下来来看看 <code>msg.target.dispatchMessage(msg)</code> ，这里的 <code>target</code> 是一个 Handler 是否还记得呢，在  <code>Handler().enqueueMessage()</code>  消息入队之前会将当前 Handler 对象赋值给 <code>Message.target</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息分发流程：</p><ol><li>当 Message.callback 不为空时，回调  message.callback.run() 方法，其中 callback 的类型是 Runnable 类型，当你使用 Handler.post 系列方法时候，就会调用；如果 Message.callback 为空进入流程 2。</li><li>如果 Handler.mCallback 不会空则先调用 mCallback.handleMessage(msg)，否则进入流程 3。注意：若 mCallback.handleMessage(msg) 返回 true，整个流程到此为止。</li><li>最后，调用 Handler 自身的 handleMessage() 方法，该方法为空实现需要子类覆写。</li></ol><p>至此，我们已经完成从 Handler.send() 发送消息开始到最后 Handler 接收并处理消息的整体流程的解析，同时也在这个过程中解答了【<strong>疑问 2、3</strong>】。</p><p>那还有最后一个疑问，Handler 是如何线程切换的呢？</p><p>注：原先想按照自己的思路描述，但写完之后发现不够简洁，因此在这里引用了【<strong>六、参考与推荐 3</strong>】文章中描述。</p><p>很多人搞不懂这个原理，但是其实非常简单，我们将所涉及的方法调用栈画出来，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread &#123;</span><br><span class="line">Looper.loop()</span><br><span class="line"> -&gt; MessageQueue.next()</span><br><span class="line">   -&gt; Message.target.dispatchMessage()</span><br><span class="line">    -&gt; Handler.handleMessage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显而易见，Handler.handleMessage() 所在的线程最终由调用 Looper.loop() 的线程所决定。</strong></p><p>平时我们用的时候从异步线程发送消息到 Handler，这个 Handler 的 <code>handleMessage()</code> 方法是在主线程调用的，所以消息就从异步线程切换到了主线程。</p><h2 id="四、Handler-扩展"><a href="#四、Handler-扩展" class="headerlink" title="四、Handler 扩展"></a>四、Handler 扩展</h2><h3 id="4-1-IdleHandler"><a href="#4-1-IdleHandler" class="headerlink" title="4.1 IdleHandler"></a>4.1 IdleHandler</h3><p>IdleHandler 简单来说就是一个接口，只不过它在 Handler 当中仅仅会在消息空闲的时候执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用执行的代码在 <code>MessageQueue.next()</code> 方法中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>最后，我们结合图片来尝试对 Handler 做个总结。</p><blockquote><p>图片来源【<strong>六、参考与推荐 2</strong>】</p></blockquote><p><img src="/.cn//handler_architecture.jpg" alt="handler_architecture"></p><p><img src="/.cn//handler_process.jpg" alt="handler_process"></p><ul><li>Looper：不断的执行循环（<code>Looper.loop()</code>）从持有的 MessageQueue 队列中读取 Message （<code>MessageQueue.next()</code>），分发给对应的 Handler 处理；</li><li>MessageQueue：消息队列，通过 <code>MessageQueue.enqueueMessage()</code> 方法对从 Handler 发送过来的 Message 进行入队存储。</li><li>Handler：消息辅助类，负责发送和处理 Message。</li></ul><p>简单一句话概括：<strong>Handler 通过 sendMessage() 发送 Message 到 MessageQueue 队列中，并由 Looper 通过 loop() 不断循环从 MessageQueue 中读取 Message，将其通过 Message.target.dispatchMessage() 交给 Handler 处理。</strong></p><h2 id="六、参考与推荐"><a href="#六、参考与推荐" class="headerlink" title="六、参考与推荐"></a>六、参考与推荐</h2><ol><li><a href="https://www.zhihu.com/question/34652589/answer/90344494" target="_blank" rel="noopener">Android 中为什么主线程不会因为 Looper.loop() 里的死循环卡死</a></li><li><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制1-Handler（Java 层）</a></li><li><a href="https://juejin.im/post/5c74b64a6fb9a049be5e22fc#heading-0" target="_blank" rel="noopener">Handler 都没搞懂，拿什么去跳槽啊</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;Handler 在我们日常开发中随处可见，一般用来解决子线程无法访问主线程（UI 线程）中的 UI 问题的。&lt;/p&gt;
&lt;p&gt;下文会通过 Handler 的基本用法，并深入源码浅析 Handler 的运行机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://wangpeiyuan.cn/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android device monitor 在 Mac 上无法点击的解决方案</title>
    <link href="http://wangpeiyuan.cn/2019/10/10/Android-device-monitor-freezes-on-mac/"/>
    <id>http://wangpeiyuan.cn/2019/10/10/Android-device-monitor-freezes-on-mac/</id>
    <published>2019-10-10T07:07:30.000Z</published>
    <updated>2019-11-26T13:56:20.275Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 Mac 上使用 Android device monitor 多次遇到无法点击以及一打开就弹出 An error has occurred 的错误弹窗，主要的原因是升级了相关了 SDK 导致出现问题。在网上搜索解决方案绝大多数的答案是将 Java SDK 的版本降到一个指定版本，非得降级不可吗，如果不降级就没有解决方案吗？经过我各种搜索各种尝试终于在 Stackoverflow 上搜索到一个解决方案 <a href="https://stackoverflow.com/questions/47089757/android-device-monitor-freezes-on-mac-os-x/47090518" target="_blank" rel="noopener">Android device monitor freezes on Mac OS X</a> ，就在此简单做个记录。</p><a id="more"></a><p>对于无法点击的问题，首先先下载 <a href="https://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops4/R-4.7.1a-201710090410/swt-4.7.1a-cocoa-macosx-x86_64.zip" target="_blank" rel="noopener">swt-4.7.1a-cocoa-macosx-x86_64.zip</a>；然后，解压，重命名解压文件中的 swt.jar 文件名称为 Android/sdk/tools/lib/monitor-x86_64/plugins 中 org.eclipse.swt.cocoa.macosx.x86_64…jar 的名字；最后拷贝过来覆盖 SDK 中的文件就解决无法点击的相关问题。</p><p>打开 Android device monitor 会弹出 An error has occurred 的错误弹窗暂时没有找到好的解决方案，由于我并没有尝试降级 Java SDK 的方案，并不确定降级是否可以解决，那我的解决方式比较简单粗暴重新下载 Android SDK 就解决了此问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 Mac 上使用 Android device monitor 多次遇到无法点击以及一打开就弹出 An error has occurred 的错误弹窗，主要的原因是升级了相关了 SDK 导致出现问题。在网上搜索解决方案绝大多数的答案是将 Java SDK 的版本降到一个指定版本，非得降级不可吗，如果不降级就没有解决方案吗？经过我各种搜索各种尝试终于在 Stackoverflow 上搜索到一个解决方案 &lt;a href=&quot;https://stackoverflow.com/questions/47089757/android-device-monitor-freezes-on-mac-os-x/47090518&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android device monitor freezes on Mac OS X&lt;/a&gt; ，就在此简单做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://wangpeiyuan.cn/categories/Android/"/>
    
    
  </entry>
  
</feed>
